@prefix lexo: <http://example.org/lexo#> .
@prefix stanford: <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/vm/dep/stanford#> .
@prefix olia: <http://purl.org/olia/olia.owl#> .
@prefix nif: <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/nif-core#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix owl: <http://www.w3.org/2002/07/owl#>.


lexo:IntersectiveAdjective a lexo:Preprocessing ;
  rdfs:label "Intersective Adjective" ;
  lexo:query """
  CONSTRUCT
  {
     ?gov lexo:pragma [
             lexo:source lexo:IntersectiveAdjective ;
             lexo:axiomType  owl:intersectionOf ;
             lexo:mergeType1 "and" ;
             lexo:mergeType2 "and" ;
             lexo:target ?dep ] .
    ?dep lexo:handled "true" .
   } {
    ?gov  stanford:amod ?dep .
    ?dep  nif:oliaCategory  ?adjectiveOrParticiple .
    FILTER (?adjectiveOrParticiple IN (olia:Participle,olia:Adjective )) .
    ?dep  nif:lemma ?lemma .
    ?dep  nif:anchorOf ?anchorOf .
    BIND (IRI(concat("http:/example.org/lexotype#",ucase(substr(?lemma,1,1)),if(?adjectiveOrParticiple=olia:Adjective, substr(?lemma,2),substr(?anchorOf,2)),"_Thing")) AS ?name) .
    FILTER NOT EXISTS { ?dep lexo:adjectiveType lexo:Subsective}.
    FILTER NOT EXISTS { ?dep lexo:adjectiveType lexo:Privative}.
  }
  """.

lexo:ModifyingParticiple a lexo:Preprocessing ;
  rdfs:label "Modifying Participle" ;
  lexo:query """
  CONSTRUCT
  {
    ?gov lexo:pragma [
                 lexo:source lexo:ModifyingParticiple ;
                 lexo:axiomType  owl:intersectionOf ;
                 lexo:mergeType1 "and" ;
                 lexo:mergeType2 "and" ;
                 lexo:target ?dep ] .

   } {
    ?gov stanford:partmod ?dep .
    ?dep nif:oliaCategory olia:Participle .
  }
  """.


 lexo:DirectObject a lexo:Preprocessing ;
   rdfs:label "Direct Object" ;
   lexo:query """
   CONSTRUCT
   {
        ?verb lexo:pragma [
                     lexo:source lexo:DirectObject ;
                     lexo:axiomType  owl:someValuesFrom ;
                     #TODO correct?
                     lexo:mergeType1 "and" ;
                     lexo:mergeType2 "or" ;
                     lexo:property ?name ;
                     lexo:target ?target ] .

    } {
     ?verb  stanford:dobj ?target .
     ?verb nif:oliaCategory olia:Verb .
     ?verb nif:lemma ?lemma .
      BIND (IRI(concat("http:/example.org/lexoprop#",str(?lemma))) as ?name ) .
   }
   """.

lexo:RelativeClause a lexo:Preprocessing ;
  rdfs:label "Relative Clause" ;
  lexo:query """
  CONSTRUCT
  {
     ?gov lexo:pragma [
             lexo:source lexo:RelativeClause ;
             lexo:axiomType  owl:intersectionOf ;
             lexo:mergeType1 "and" ;
             lexo:mergeType2 "or" ;
             lexo:target ?dep ] .
   } {
     ?gov stanford:rcmod ?dep .
  }
  """.

lexo:SimpleNoun a lexo:Preprocessing ;
    rdfs:label "Simple Noun" ;
     lexo:query """
     CONSTRUCT
     {
       ?class lexo:compound [ lexo:cnOrder ?order ; lexo:cnName ?name  ]
   } {
           ?class  nif:oliaCategory olia:Noun ;
                   nif:beginIndex ?order ;
                   nif:lemma ?lemma .
            FILTER (NOT EXISTS { [] stanford:nn ?class }) .
            BIND (concat(ucase(substr(?lemma,1,1)),substr(?lemma,2)) AS ?name) .
     }
     """.


lexo:CompoundNoun a lexo:Preprocessing ;
  rdfs:label "Compound Noun" ;
  lexo:query """
  CONSTRUCT
  {
    ?class lexo:compound [ lexo:cnOrder ?order ; lexo:cnName ?name  ]  .
    ?compound lexo:handled "true" .
   } {
      ?class  nif:oliaCategory olia:Noun ;
              stanford:nn  ?compound    .
      ?compound   nif:oliaCategory olia:Noun ;
                  nif:beginIndex ?order ;
                  nif:lemma ?lemma .
      BIND (concat(ucase(substr(?lemma,1,1)),substr(?lemma,2)) AS ?name) .
  }
  """.

  lexo:CoumpoundNounSubclass a lexo:Preprocessing ;
    lexo:query """
    CONSTRUCT
    {
      ?class lexo:pragma [
                   lexo:source lexo:CoumpoundNounSubclass ;
                   lexo:axiomType  rdfs:subClassOf ;
                   lexo:mergeType1 "simple" ;
                   lexo:target ?name ] .
    } {
        ?class  nif:oliaCategory olia:Noun ;
                nif:lemma ?lemma  ;
                stanford:nn  ?compound  .
        ?compound   nif:oliaCategory olia:Noun .
        BIND (IRI(concat("http:/example.org/lexotype#",ucase(substr(?lemma,1,1)),substr(?lemma,2))) AS ?name) .
    }
    """.

lexo:VerbWithPreposition a lexo:Preprocessing ;
    lexo:query """
    CONSTRUCT
    {
      ?verb lexo:pragma [
             lexo:source lexo:VerbWithPreposition ;
             lexo:axiomType  owl:someValuesFrom ;
             lexo:mergeType1 "and" ;
             lexo:mergeType2 "or" ;
             lexo:property ?name ;
             lexo:target ?target ] .

    } {
        ?verb  nif:oliaCategory olia:Verb ;
               nif:lemma ?lemma  .
        ?verb ?prep ?target .

        BIND (IRI(concat("http:/example.org/lexoprop#",str(?lemma), substr(str(?prep),75))) as ?name ) .
        FILTER (strStarts ( str (?prep), "http://persistence.uni-leipzig.org/nlp2rdf/ontologies/vm/dep/stanford#prep_"  )) .
    }
    """.

lexo:NounWithPreposition a lexo:Preprocessing ;
    lexo:query """
    CONSTRUCT
    {
      #?noun lexo:prep [ lexo:prepName ?name ; lexo:prepTarget ?target  ] .
      ?noun lexo:pragma [
           lexo:source lexo:NounWithPreposition ;
           lexo:axiomType  owl:someValuesFrom ;
           lexo:mergeType1 "and" ;
           lexo:mergeType2 "or" ;
           lexo:property ?name ;
           lexo:target ?target ] .
      ?target lexo:handled "true" .
    } {
        ?noun  nif:oliaCategory olia:Noun ;
               nif:lemma ?lemma  .
        ?noun ?prep ?target .

        BIND (IRI(concat("http:/example.org/lexoprop#", substr(str(?prep),76))) as ?name ) .
        FILTER (strStarts ( str (?prep), "http://persistence.uni-leipzig.org/nlp2rdf/ontologies/vm/dep/stanford#prep_"  )) .
    }
    """.

lexo:EquivalentDefinitions a lexo:Preprocessing ;
    lexo:query """
    CONSTRUCT
    {
      ?terma lexo:pragma [
                     lexo:source lexo:EquivalentDefinitions ;
                     lexo:axiomType owl:equivalentClass ;
                     lexo:mergeType1 "simple" ;
                     lexo:target ?termb ] .
    } {
        ?definition stanford:nsubj ?terma .
        ?definition stanford:nsubj ?termb .
        FILTER (?terma != ?termb ) .
    }
    """.

lexo:Copula a lexo:Preprocessing ;
    lexo:query """
    CONSTRUCT
    {
      ?term lexo:pragma [
               lexo:source lexo:Copula ;
               lexo:axiomType rdfs:subClassOf ;
               lexo:mergeType1 "simple" ;
               lexo:target ?definition ] .
      ?cop lexo:handled "true" .
    } {
        ?definition stanford:nsubj ?term .
        ?definition stanford:cop ?cop .
        ?cop nif:lemma "be" ;
             nif:oliaCategory olia:Verb  .
        #?term nif:oliaCategory ?termCat .
        FILTER ( NOT EXISTS { ?term nif:oliaCategory olia:Determiner} )
    }

    """.

# TODO is able to JJ with xcomp